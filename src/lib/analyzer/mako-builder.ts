import type { ActionItem } from "./action-extractor";
import type { LinkItem } from "./link-extractor";
import { countTokens } from "./token-counter";

export interface BuilderInput {
  markdown: string;
  contentType: string;
  entity: string;
  summary: string;
  actions: ActionItem[];
  links: { internal: LinkItem[]; external: LinkItem[] };
  language: string;
  url: string;
  tokens?: number;
}

/** Section templates per content type */
const SECTION_MAP: Record<string, string[]> = {
  product: ["Key Facts", "Context", "Reviews Summary"],
  article: ["Summary", "Key Points", "Context"],
  docs: ["Overview", "Usage", "Parameters/API", "See Also"],
  landing: ["What It Does", "Key Features", "Pricing", "Alternatives"],
  listing: ["Items", "Filters Available"],
  profile: ["About", "Key Information", "Notable Work"],
  event: ["Details", "Description", "Registration"],
  recipe: ["Ingredients", "Steps", "Notes"],
  faq: [], // FAQ uses questions as headings
  custom: [], // flexible
};

export function buildMakoFile(data: BuilderInput): {
  content: string;
  headers: Record<string, string>;
} {
  const today = new Date().toISOString().split("T")[0];
  const summary = data.summary || deriveSummary(data.markdown);
  const body = buildBody(data.markdown, data.contentType);
  const bodyTokens = countTokens(body);

  // Build YAML frontmatter
  const frontmatter = buildFrontmatter({
    contentType: data.contentType,
    entity: data.entity,
    updated: today,
    tokens: bodyTokens,
    language: data.language,
    summary,
    actions: data.actions,
    links: data.links,
  });

  const content = [
    "---",
    frontmatter,
    "---",
    "",
    body,
    "",
    "<!-- Generated by rule-based analysis (not AI-generated) -->",
  ].join("\n");

  // Build HTTP headers
  const headers: Record<string, string> = {
    "X-Mako-Version": "1.0",
    "X-Mako-Tokens": String(bodyTokens),
    "X-Mako-Type": data.contentType,
    "X-Mako-Lang": data.language,
    "Content-Type": "text/mako+markdown; charset=utf-8",
  };

  if (data.entity && data.entity !== "Unknown") {
    headers["X-Mako-Entity"] = data.entity;
  }

  headers["X-Mako-Updated"] = `${today}T00:00:00Z`;

  if (data.actions.length > 0) {
    headers["X-Mako-Actions"] = data.actions.map((a) => a.name).join(",");
  }

  if (data.url) {
    headers["X-Mako-Canonical"] = data.url;
  }

  return { content, headers };
}

function buildFrontmatter(data: {
  contentType: string;
  entity: string;
  updated: string;
  tokens: number;
  language: string;
  summary: string;
  actions: ActionItem[];
  links: { internal: LinkItem[]; external: LinkItem[] };
}): string {
  const lines: string[] = [];

  lines.push(`mako: "1.0"`);
  lines.push(`type: ${data.contentType}`);
  lines.push(`entity: ${yamlString(data.entity)}`);
  lines.push(`updated: "${data.updated}"`);
  lines.push(`tokens: ${data.tokens}`);
  lines.push(`language: "${data.language}"`);
  lines.push(`summary: ${yamlString(data.summary)}`);

  // Actions
  if (data.actions.length > 0) {
    lines.push("actions:");
    for (const action of data.actions) {
      lines.push(`  - name: ${action.name}`);
      lines.push(`    description: ${yamlString(action.description)}`);
    }
  }

  // Links
  const hasInternal = data.links.internal.length > 0;
  const hasExternal = data.links.external.length > 0;

  if (hasInternal || hasExternal) {
    lines.push("links:");

    if (hasInternal) {
      lines.push("  internal:");
      for (const link of data.links.internal) {
        lines.push(`    - url: ${link.url}`);
        lines.push(`      context: ${yamlString(link.context)}`);
      }
    }

    if (hasExternal) {
      lines.push("  external:");
      for (const link of data.links.external) {
        lines.push(`    - url: ${link.url}`);
        lines.push(`      context: ${yamlString(link.context)}`);
      }
    }
  }

  return lines.join("\n");
}

function buildBody(markdown: string, contentType: string): string {
  const sections = SECTION_MAP[contentType];

  // For FAQ and custom types, or if no sections defined, return markdown as-is
  if (!sections || sections.length === 0) {
    return markdown;
  }

  // Split markdown into rough chunks based on existing headings
  const existingHeadings = markdown.match(/^#{1,6}\s+.+$/gm) || [];

  // If the markdown already has good structure with headings, use it as-is
  if (existingHeadings.length >= 2) {
    return markdown;
  }

  // Otherwise, wrap content under the first section heading
  // and split into sections heuristically
  const paragraphs = markdown
    .split(/\n\n+/)
    .filter((p) => p.trim().length > 0);

  if (paragraphs.length === 0) return markdown;

  // Simple heuristic: distribute paragraphs across sections
  const result: string[] = [];
  const perSection = Math.max(1, Math.ceil(paragraphs.length / sections.length));

  for (let i = 0; i < sections.length; i++) {
    const start = i * perSection;
    const end = Math.min(start + perSection, paragraphs.length);
    const sectionParagraphs = paragraphs.slice(start, end);

    if (sectionParagraphs.length > 0) {
      result.push(`## ${sections[i]}`);
      result.push(sectionParagraphs.join("\n\n"));
      result.push("");
    }
  }

  return result.join("\n").trim();
}

/**
 * Derive a summary from the first meaningful paragraph of markdown.
 * Max 160 characters.
 */
function deriveSummary(markdown: string): string {
  const paragraphs = markdown.split(/\n\n+/);

  for (const p of paragraphs) {
    const cleaned = p
      .replace(/^#{1,6}\s+/gm, "") // Remove heading markers
      .replace(/[*_`\[\]()]/g, "") // Remove markdown formatting
      .replace(/\s+/g, " ")
      .trim();

    if (cleaned.length >= 20) {
      if (cleaned.length <= 160) return cleaned;
      return cleaned.slice(0, 157) + "...";
    }
  }

  return "";
}

/**
 * Safely wrap a value in YAML double-quoted string format.
 */
function yamlString(value: string): string {
  const escaped = value
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\\"')
    .replace(/\n/g, "\\n");
  return `"${escaped}"`;
}
